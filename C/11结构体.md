# 结构体

* 结构体
* 结构体数组
* 结构体内存对齐
* 结构体位字段
* 联合体

## C 结构体

* 不变的数据用常量来处理
* 变化的数据用变量来处理
* 同类型的多个数据用数组来处理
* 那具有多个不同类型的数据的集合用什么来处理？答案就是用**结构体**
* **结构体**就是把具有内在联系的多个不通过类型的数据结合成一个整体，使他们关联起来。

### 定义结构体类型

```c
struct point
{
    int x;
    int y;
};

struct point
{
    int x;
    int y;
} p1;   // 这里定义结构体的同时也定义了一个变量叫做 `p1`, 等价与 `struct point p1;`

typedef struct point 
{
    int x;
    int y;
} point_t; // typedef 为现有类型创建一个新的名字，称为类型别名

struct point
{
    int x;
    int y;
};
// typedef 为现有类型创建一个新的名字，称为类型别名
typedef struct point point_t;

// 结构体中可以嵌套结构体
struct circle
{
    struct point center;
    int radius;
};
```

> **注意**
> 结构体定义中不能定义自身
> 但是可以定义自身的指针类型

```c
struct list {
    struct list next;  // 错误的定义
    struct list *next;  // 正确的定义
};
```

### 结构体变量的初始化

```c
point_t p1 = {1, 2};
circle_t c1 = {{1, 2}, 3};
circle_t c2 = {1, 2, 3};
circle_t c3 = {p1, 3};
```

结构体元素通过使用 `.` 来引用，这个运算符也称为成员运算符

```c
p1.x
c1.center.x
```

> **注意：**
> 结构体可以整体赋值
> 数组不能整体赋值

## 结构体数组

我们可以定义`int`、`char`、等不同类型的数组，当然我们也可以定义结构体数组。

```c
typedef struct student;
{
    char name[16];
    int age;
    char sex;
} student_t;

student_t stu[] = {
    {"A", 20, 'M'},
    {"B", 22, 'F'},
    {"C", 24, 'M'},
}
```

## 结构体内存对齐

* 什么是结构体内存对齐
* 为什么要对齐
  * 数据存储于对齐的内存地址中，CPU 读取数据的速度会大大提升
* 如何对齐

```c
typedef struct test
{
    char a;
    double b;
    char c;
} test_t;
```

在上面的结构体 `test` 中，`char a` 需要1个字节的空间，`double b` 需要8个字节空间，`c` 需要1个字节空间，所以总共需要10个字节的内存空间。但实际上结构体的每个成员所占的内存大小都要是**对齐模数**的整数倍。所以上面的 `test` 结构体中我们假设，内存地址从1000开始。那么有：

`char a` 所占用的内存地址应该是1000
`double b` 占用的内存地址是1004~1011
`char c` 占用的内存地址是1012

这样看一共占用了13个字节的内存空间，但是对于 `test` 结构体来说它本身所占用的内存空间的大小也应该是**对齐模数**的整数倍，这里 `test` 对应的对齐模式是4，所以对于 `test` 结构体它实际所占用的内存空间大小为16个字节。

### 对齐规则

1. 第一个数据成员对齐至偏移地址为0的地方。
2. 接下来的数据成员对齐至对齐模数的整数倍。每个成员都有自己的对齐模数
3. 对齐模数取数据成员的大小与 `#pragma pack(n)` (对齐值，gcc默认是4，vc默认是8) 两者中的较小值。
4. 整个结构体的大小对齐至其成员最大对齐模数的整数倍。

## 结构体位字段

```c
typedef struct pack
{
    int a: 1;
    int b: 2;
    int c: 3;
} pack_t;
```

上面的结构体指明变量`a` 占用1位的内存空间，`b` 占用2位内存空间，`c` 占用3位内存空间，所以一共占用6位的内存空间也就是说实际上`pack`所需的内存空间大小还不足1个字节。但是由于int类型需要占用4个字节的内存空间，那么意味着 `pack` 它的对齐模数是4，所以结构体`pack` 的实际占用内存空间的大小为4个字节。

## 联合体

```c
union data 
{
    int n;
    char c;
    double d;
};
```

联合体的数据成员共用一块内存空间。联合体的大小是其最大数据成员的大小,也就是说上面的结构体占用的大小为 `double d` 所需的大小。也就是8个字节。
